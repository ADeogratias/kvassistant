import 'dart:io';

import 'package:audioplayers/audioplayers.dart';
import 'package:just_audio/just_audio.dart' as JustAudio;
import 'package:flutter/material.dart';
import 'package:avatar_glow/avatar_glow.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record_mp3/record_mp3.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider/path_provider.dart';

// void main() => runApp(const MyApp());

// class MyApp extends StatefulWidget {
//     const MyApp({super.key});

//     // This widget is the root of your application.
//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       title: 'Digital Umuganda',
//       theme: ThemeData(

//         primarySwatch: Colors.blue,
//       ),
//       home: const MyHomePage(title: 'Digital Umuganda'),
//     );
//   }
// }

// class MyHomePage extends StatefulWidget {
//   const MyHomePage({super.key, required this.title});

//   final String title;

//   @override
//   State<MyHomePage> createState() => _MyHomePageState();
//   // _MainPageSate createState() => _MainPageSate();
// }

void main() => runApp(
      MaterialApp(
        home: MyHomePage(),
      ),
    );

class MyHomePage extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    // TODO: implement createState
    return _MyHomePageState();
  }
}

// class _MyHomePageState extends State<MyHomePage> {

class _MyHomePageState extends State<MyHomePage> {
  final recorder = FlutterSoundRecorder();
  final recordPlayer = FlutterSoundRecorder();
  // final Codec _codec    = Codec.mp3;
  // final String _mpath   = 'audio.mp3';
  final String _mpath =
      '/data/user/0/com.example.du_voice_assistant/cache/audio';
  bool isRecorderReady = false;
  //String _pathToAudio = '/sdcard/myAudio.aac';
  String _fileName = '';
  String _path = "";

  /*
  *  playing the audio from the recorded file.
  */
  final audioPlayer = AudioPlayer();
  bool isPlaying = false;
  Duration duration = Duration.zero;
  Duration position = Duration.zero;

  // RecordMp3.instance.start(, mp2)

  @override
  void initState() {
    super.initState();

    initRecorder();

    setAudio();

    // final directory = await getApplicationDocumentsDirectory();
    // _path = directory.path;

    // audioPlayer.onPlayerStateChanged.listen((state) {
    //   setState(() {
    //     // isPlaying = state == PlayerState.PLAYING;
    //   });
    // });

    // audioPlayer.onDurationChanged.listen((newDuration) {
    //   setState(() {
    //     duration = newDuration;
    //   });
    //  });

    //  audioPlayer.onDurationChanged.listen((newPosition) {
    //   setState(() {
    //     position = newPosition;
    //   });
    //   });
  }

  /* code to get path to use for the models */

  // Future<Directory> getApplicationDocumentsDirectory() async {
  // final String? path = await _platform.getApplicationDocumentsPath();
  // if (path == null) {
  //   throw MissingPlatformDirectoryException(
  //       'Unable to get application documents directory');
  // }
  //   return Directory(path);
  // }

  Future setAudio() async {
    // repeat sound when completed
    // audioPlayer.setReleaseMode(ReleaseMode.loop);

    // String url =
    // audioPlayer.setSourceUrl(url);

    final player = AudioCache(prefix: 'assets/sound/');
    final url = await player.load('audio');
    audioPlayer.setSourceUrl(url.path); //, isLocal:true);
    //load audion from File
    // final result = await FilePicker.platform.pickFiles();

    // if (result != null){
    // final file = File(result.files.single.path!);
    // audioPlayer.setSourceUrl(file.path, isLocal: true);
    // audioPlayer.setUrl(file.path);

    // }
  }

  @override
  void dispose() {
    recorder.closeRecorder();

    super.dispose();
  }

  Future initRecorder() async {
    final status = await Permission.microphone.request();

    if (status != PermissionStatus.granted) {
      throw 'Microphone permission not granted';
    }

    await recorder.openRecorder();

    isRecorderReady = true;
    recorder.setSubscriptionDuration(
      const Duration(milliseconds: 500),
    );
  }

  Future record() async {
    if (!isRecorderReady) return;

    await recorder.startRecorder(toFile: 'audio.aac');

    // await recorder.startRecorder(
    //   toFile: _mpath,
    //   // codec: _codec,
    //   ).then((value) {}); // audioSource: AudioSource.microphone,);

    // setState(() {
    //     print('Recording audio... ');
    // });
  }

  File? audioFile;
  Future stop() async {
    if (!isRecorderReady) return;

    // await recorder.stopRecorder().then((value) {
    // setState(() {
    //   var audioFile = value;
    //   print('Recorded audio: $audioFile');
    // });
    // });

    final path = await recorder.stopRecorder();
    setState(() {
      audioFile = File(path!);
    });

    print('Recorded audio: $audioFile');
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        backgroundColor: Colors.white,
        body: Center(
          child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
            StreamBuilder<RecordingDisposition>(
                stream: recorder.onProgress,
                builder: (context, snapshot) {
                  final duration = snapshot.hasData
                      ? snapshot.data!.duration
                      : Duration.zero;

                  return Text('${duration.inSeconds} s');
                }),
            const SizedBox(height: 32),
            ElevatedButton(
              child: Icon(
                recorder.isRecording ? Icons.stop : Icons.mic,
                size: 80,
              ),
              onPressed: () async {
                if (recorder.isRecording) {
                  await stop();
                } else {
                  await record();
                }

                setState(() {});
              },
            ),

            TextButton(
              onPressed: () async {
                print('got here');
                // print(audioFile!.path); // this is not running
                // print('$audioFile');
                // audioPlayer.set
                try {
                  // final playerlink = await AudioCache.load(audioFile!.path)
                  // await audioPlayer.play(AssetSource('audios/audio.mp3'));
                  // final recordedAudio = audioPlayer.setSource(audioFile!.path);
                  // await audioPlayer.play();
                  // await audioPlayer.play(UrlSource(audioFile!.path));
                  print("playing audio stored at $audioFile");
                } catch (e) {
                  print(e);
                }
              },
              child: const Text('Play the damn sound'),
            ),

            // CircleAvatar(
            //   radius: 35,
            //   child: IconButton(
            //     icon: Icon(
            //       isPlaying ? Icons.pause : Icons.play_arrow,
            //     ),
            //     iconSize: 50,
            //     onPressed: () async {
            //       if (isPlaying){
            //         await audioPlayer.pause();
            //       }else {
            //         await audioPlayer.resume();
            //       }
            //     } ,
            //   ),
            // )
          ]),
        ),
      );
}

// class MyHomePage extends StatefulWidget {
//   const MyHomePage({super.key, required this.title});

//   final String title;

//   @override
//   State<MyHomePage> createState() => _MyHomePageState();
// }

// class _MyHomePageState extends State<MyHomePage> {
//   int _counter = 0;
//   bool _isListening = false;

//   void _incrementCounter() {
//     setState(() {
//       // This call to setState tells the Flutter framework that something has
//       // changed in this State, which causes it to rerun the build method below
//       // so that the display can reflect the updated values. If we changed
//       // _counter without calling setState(), then the build method would not be
//       // called again, and so nothing would appear to happen.
//       _counter++;
//     });
//   }

//   @override
//   Widget build(BuildContext context) {

//     // This method is rerun every time setState is called, for instance as done
//     // by the _incrementCounter method above.
//     //
//     // The Flutter framework has been optimized to make rerunning build methods
//     // fast, so that you can just rebuild anything that needs updating rather
//     // than having to individually change instances of widgets.
//     return Scaffold(
//       appBar: AppBar(
//         // Here we take the value from the MyHomePage object that was created by
//         // the App.build method, and use it to set our appbar title.
//         title: Text(widget.title),
//       ),

//       floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
//       floatingActionButton: AvatarGlow(
//         animate: true,//_isListening,
//         glowColor: Theme.of(context).primaryColor,
//         endRadius: 75.0,
//         duration: const Duration(milliseconds: 2000),
//         repeatPauseDuration: const Duration(milliseconds: 100),
//         repeat: true,
//         child: FloatingActionButton(
//           onPressed: (){}, // _listen,
//           child: Icon(_isListening ? Icons.mic : Icons.mic_none),
//         ),
//       ),

//       body: Center(
//         // Center is a layout widget. It takes a single child and positions it
//         // in the middle of the parent.
//         child: Column(
//           // Column is also a layout widget. It takes a list of children and
//           // arranges them vertically. By default, it sizes itself to fit its
//           // children horizontally, and tries to be as tall as its parent.
//           //
//           // Invoke "debug painting" (press "p" in the console, choose the
//           // "Toggle Debug Paint" action from the Flutter Inspector in Android
//           // Studio, or the "Toggle Debug Paint" command in Visual Studio Code)
//           // to see the wireframe for each widget.
//           //
//           // Column has various properties to control how it sizes itself and
//           // how it positions its children. Here we use mainAxisAlignment to
//           // center the children vertically; the main axis here is the vertical
//           // axis because Columns are vertical (the cross axis would be
//           // horizontal).
//           mainAxisAlignment: MainAxisAlignment.center,
//           children: <Widget>[
//             const Text(
//               'You have pushed the button',
//             ),
//             // Text(
//             //   '$_counter',
//             //   style: Theme.of(context).textTheme.headlineMedium,
//             // ),

//             // FloatingActionButton(
//             //   onPressed: _incrementCounter,
//             //   tooltip: 'Increment',
//             //   child: const Icon(Icons.add),
//             // ),
//           ],
//         ),
//       ),
//       // floatingActionButton: FloatingActionButton(
//       //   onPressed: _incrementCounter,
//       //   tooltip: 'Increment',
//       //   child: const Icon(Icons.add),
//       // ),
//     );
//   }

//   // void _listen() async {
//   //   if(!_isListening){
//   //     bool available = await _speech.initialize(
//   //       onStatus: (val) => print('onStatus: $val'),
//   //       onError: (val) => print('onError: $val'),
//   //     );
//   //     if(available){
//   //       setState(() => _isListening = true);
//   //     }
//   //     else{
//   //       setState(() => _isListening = false);
//   //     }
//   //   }
//   // }
// }

// import 'dart:io';
// import 'package:audioplayers/audioplayers.dart';
// import 'package:flutter/material.dart';
// import 'dart:async';
// import 'package:path_provider/path_provider.dart';
// import 'package:record_mp3/record_mp3.dart';
// import 'package:permission_handler/permission_handler.dart';
// import 'package:file_picker/file_picker.dart';

// void main() => runApp(MyApp());

// class MyApp extends StatefulWidget {
//   @override
//   _MyAppState createState() => _MyAppState();
// }

// class _MyAppState extends State<MyApp> {
//   String statusText = "";
//   String recordFilePath = "";
//   bool isComplete = false;

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//         appBar: AppBar(
//           title: const Text('Plugin example app'),
//         ),
//         body: Column(children: [
//           Row(
//             mainAxisAlignment: MainAxisAlignment.spaceBetween,
//             children: <Widget>[
//               Expanded(
//                 child: GestureDetector(
//                   child: Container(
//                     height: 48.0,
//                     decoration: BoxDecoration(color: Colors.red.shade300),
//                     child: Center(
//                       child: Text(
//                         'start',
//                         style: TextStyle(color: Colors.white),
//                       ),
//                     ),
//                   ),
//                   onTap: () async {
//                     startRecord();
//                   },
//                 ),
//               ),
//               Expanded(
//                 child: GestureDetector(
//                   child: Container(
//                     height: 48.0,
//                     decoration: BoxDecoration(color: Colors.blue.shade300),
//                     child: Center(
//                       child: Text(
//                         RecordMp3.instance.status == RecordStatus.PAUSE
//                             ? 'resume'
//                             : 'pause',
//                         style: TextStyle(color: Colors.white),
//                       ),
//                     ),
//                   ),
//                   onTap: () {
//                     pauseRecord();
//                   },
//                 ),
//               ),
//               Expanded(
//                 child: GestureDetector(
//                   child: Container(
//                     height: 48.0,
//                     decoration: BoxDecoration(color: Colors.green.shade300),
//                     child: Center(
//                       child: Text(
//                         'stop',
//                         style: TextStyle(color: Colors.white),
//                       ),
//                     ),
//                   ),
//                   onTap: () {
//                     stopRecord();
//                   },
//                 ),
//               ),
//             ],
//           ),
//           Padding(
//             padding: const EdgeInsets.only(top: 20.0),
//             child: Text(
//               statusText,
//               style: TextStyle(color: Colors.red, fontSize: 20),
//             ),
//           ),
//           GestureDetector(
//             behavior: HitTestBehavior.opaque,
//             onTap: () {
//               play();
//             },
//             child: Container(
//               margin: EdgeInsets.only(top: 30),
//               alignment: AlignmentDirectional.center,
//               width: 100,
//               height: 50,
//               child: isComplete && recordFilePath != null
//                   ? Text(
//                       "play",
//                       style: TextStyle(color: Colors.red, fontSize: 20),
//                     )
//                   : Container(),
//             ),
//           ),
//         ]),
//       ),
//     );
//   }

//   Future<bool> checkPermission() async {
//     if (!await Permission.microphone.isGranted) {
//       PermissionStatus status = await Permission.microphone.request();
//       if (status != PermissionStatus.granted) {
//         return false;
//       }
//     }
//     return true;
//   }

//   void startRecord() async {
//     bool hasPermission = await checkPermission();
//     if (hasPermission) {
//       statusText = "Recording...";
//       recordFilePath = await getFilePath();
//       isComplete = false;
//       RecordMp3.instance.start(recordFilePath, (type) {
//         statusText = "Record error--->$type";
//         setState(() {});
//       });
//     } else {
//       statusText = "No microphone permission";
//     }
//     setState(() {});
//   }

//   void pauseRecord() {
//     if (RecordMp3.instance.status == RecordStatus.PAUSE) {
//       bool s = RecordMp3.instance.resume();
//       if (s) {
//         statusText = "Recording...";
//         setState(() {});
//       }
//     } else {
//       bool s = RecordMp3.instance.pause();
//       if (s) {
//         statusText = "Recording pause...";
//         setState(() {});
//       }
//     }
//   }

//   void stopRecord() {
//     bool s = RecordMp3.instance.stop();
//     if (s) {
//       statusText = "Record complete";
//       isComplete = true;
//       setState(() {});
//     }
//   }

//   void resumeRecord() {
//     bool s = RecordMp3.instance.resume();
//     if (s) {
//       statusText = "Recording...";
//       setState(() {});
//     }
//   }

//   // String recordFilePath;

//   void play() {
//     if (recordFilePath != null && File(recordFilePath).existsSync()) {
//       AudioPlayer audioPlayer = AudioPlayer();

//       final result = await FilePicker.platform.pickFiles();
//       final test = File(recordFilePath);
//       audioPlayer.play(test.path, isLocal: true);
//       // audioPlayer.setUrl(test.path, isLocal: true);
//     }
//   }

//   int i = 0;

//   Future<String> getFilePath() async {
//     Directory storageDirectory = await getApplicationDocumentsDirectory();
//     String sdPath = storageDirectory.path + "/record";
//     var d = Directory(sdPath);
//     if (!d.existsSync()) {
//       d.createSync(recursive: true);
//     }
//     return sdPath + "/test_${i++}.mp3";
//   }
// }
